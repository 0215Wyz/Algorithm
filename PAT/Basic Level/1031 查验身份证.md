一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：  
首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：
```
Z：0 1 2 3 4 5 6 7 8 9 10
M：1 0 X 9 8 7 6 5 4 3 2
```
现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。


【输入格式】：  
输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。

【输出格式】：  
输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。

【输入样例1】：
```
4
320124198808240056
12010X198901011234
110108196711301866
37070419881216001X
```

【输出样例1】：
```
12010X198901011234
110108196711301866
37070419881216001X
```

【输入样例2】：
```
2
320124198808240056
110108196711301862
```

【输出样例2】：
```
All passed
```


【AC代码】：  
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <map>

using namespace std;

int a[20] = { 7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2 };
map<int, char> m;

int main()
{
	char s[20];
	m[0] = '1';
	m[1] = '0';
	m[2] = 'X';
	m[3] = '9';
	m[4] = '8';
	m[5] = '7';
	m[6] = '6';
	m[7] = '5';
	m[8] = '4';
	m[9] = '3';
	m[10] = '2';
	int i, n;
	int sum;
	int flag = 0;
	cin >> n;
	while (n--)
	{
		cin >> s;
		sum = 0;
		for (i = 0; i < 17; i++)
		{
			sum += ((s[i] - '0')*a[i]);
		}
		sum %= 11;
		if (m[sum] != s[17])
		{
			flag = 1;
			cout << s << endl;
		}
	}
	if (flag == 0)
	{
		cout << "All passed";
	}
	return 0;
}
```